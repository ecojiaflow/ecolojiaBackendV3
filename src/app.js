const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const dotenv = require('dotenv');

dotenv.config();

const app = express();

// üîå IMPORT POOL POSTGRESQL
const { 
  testConnection, 
  isPostgreSQLConnected,
  getAllProducts,
  getProductByBarcode,
  getProductBySlug 
} = require('./db/pool');

// üì¶ PRODUITS DE SECOURS (FALLBACK UNIQUEMENT)
const fallbackProducts = [
  {
    id: "fallback_1",
    title: "Service Temporairement Indisponible",
    slug: "service-indisponible",
    description: "Le service de produits est temporairement indisponible",
    brand: "Syst√®me",
    category: "maintenance",
    eco_score: "0.50",
    ai_confidence: "1.00",
    confidence_pct: 100,
    confidence_color: "yellow",
    verified_status: "system",
    tags: ["syst√®me", "maintenance"],
    zones_dispo: ["FR"],
    image_url: "https://via.assets.so/img.jpg?w=300&h=200&tc=orange&bg=%23f3f4f6&t=Maintenance",
    prices: { default: 0 },
    resume_fr: "Service en maintenance - PostgreSQL reconnexion en cours",
    barcode: "0000000000000"
  }
];

// CORS S√âCURIS√â
const allowedOrigins = [
  'https://frontendv3.netlify.app',
  'https://ecolojiafrontv3.netlify.app',
  'https://main--frontendv3.netlify.app',
  'https://main--ecolojiafrontv3.netlify.app',
  'https://ecolojiabackendv3.onrender.com',
  'http://localhost:3000',
  'http://localhost:5173',
  'http://localhost:4173'
];

app.use(cors({
  origin: (origin, callback) => {
    if (!origin || origin.includes('.netlify.app') || allowedOrigins.includes(origin)) {
      return callback(null, true);
    }
    callback(new Error(`Origin ${origin} not allowed by CORS`));
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'x-cron-key', 'x-api-key', 'X-Requested-With', 'Accept', 'Origin']
}));

app.use(helmet({
  crossOriginEmbedderPolicy: false,
  crossOriginResourcePolicy: { policy: "cross-origin" }
}));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// üß™ ROUTE TEST
app.get('/api/test-barcode', (req, res) => {
  const dbStatus = isPostgreSQLConnected() ? 'PostgreSQL' : 'Fallback';
  res.json({ 
    success: true,
    message: 'Route barcode test fonctionne !', 
    timestamp: new Date().toISOString(),
    source: 'postgresql-activated',
    database: dbStatus,
    note: '√âTAPE 1 R√âUSSIE - PostgreSQL activ√©'
  });
});

// üì¶ ROUTE PRODUITS - POSTGRESQL PRIORITAIRE
app.get('/api/products', async (req, res) => {
  try {
    console.log(`üìã R√©cup√©ration produits (PostgreSQL prioritaire)...`);
    
    const { limit = 50, offset = 0, q } = req.query;
    
    // ESSAI POSTGRESQL EN PREMIER
    if (isPostgreSQLConnected()) {
      try {
        const products = await getAllProducts(
          parseInt(limit), 
          parseInt(offset), 
          q ? q.trim() : null
        );
        
        console.log(`‚úÖ ${products.length} produits PostgreSQL retourn√©s`);
        return res.json(products);
        
      } catch (pgError) {
        console.error('‚ùå Erreur PostgreSQL, fallback:', pgError.message);
      }
    }
    
    // FALLBACK UNIQUEMENT SI POSTGRESQL √âCHEC
    console.log('üîÑ Utilisation fallback (PostgreSQL indisponible)');
    let results = [...fallbackProducts];
    
    if (q && q.trim()) {
      const query = q.toLowerCase().trim();
      results = results.filter(product => 
        product.title.toLowerCase().includes(query) ||
        product.description.toLowerCase().includes(query) ||
        product.brand.toLowerCase().includes(query) ||
        product.tags.some(tag => tag.toLowerCase().includes(query))
      );
    }
    
    const startIndex = parseInt(offset);
    const limitNum = parseInt(limit);
    const paginatedResults = results.slice(startIndex, startIndex + limitNum);
    
    console.log(`‚ö†Ô∏è ${paginatedResults.length} produits fallback (PostgreSQL d√©connect√©)`);
    res.json(paginatedResults);
    
  } catch (error) {
    console.error('‚ùå Erreur route /products:', error);
    res.status(500).json({
      error: 'Erreur de r√©cup√©ration produits',
      message: error.message,
      source: 'postgresql_error'
    });
  }
});

// üîç ROUTE SEARCH - POSTGRESQL PRIORITAIRE
app.get('/api/products/search', async (req, res) => {
  try {
    const { q, limit = 20 } = req.query;
    
    if (!q || q.trim() === '') {
      return res.json({ products: [], count: 0, query: '', source: 'postgresql' });
    }
    
    // ESSAI POSTGRESQL
    if (isPostgreSQLConnected()) {
      try {
        const products = await getAllProducts(parseInt(limit), 0, q.trim());
        
        const searchResults = products.map(product => ({
          id: product.id,
          title: product.title,
          slug: product.slug,
          brand: product.brand,
          eco_score: product.eco_score,
          image_url: product.image_url
        }));
        
        console.log(`‚úÖ ${searchResults.length} r√©sultats recherche PostgreSQL`);
        return res.json({ 
          products: searchResults, 
          count: searchResults.length, 
          query: q.trim(),
          source: 'postgresql'
        });
        
      } catch (pgError) {
        console.error('‚ùå Erreur search PostgreSQL:', pgError.message);
      }
    }
    
    // FALLBACK SEARCH
    const query = q.toLowerCase().trim();
    const results = fallbackProducts.filter(product => 
      product.title.toLowerCase().includes(query) ||
      product.description.toLowerCase().includes(query) ||
      product.brand.toLowerCase().includes(query)
    ).slice(0, parseInt(limit));
    
    console.log(`‚ö†Ô∏è ${results.length} r√©sultats fallback search`);
    res.json({ 
      products: results, 
      count: results.length, 
      query: q.trim(),
      source: 'fallback'
    });
    
  } catch (error) {
    console.error('‚ùå Erreur search:', error);
    res.status(500).json({ 
      products: [], 
      count: 0, 
      error: 'Erreur de recherche',
      source: 'error'
    });
  }
});

// üìÑ ROUTE SLUG - POSTGRESQL PRIORITAIRE
app.get('/api/products/:slug', async (req, res) => {
  try {
    const { slug } = req.params;
    
    // ESSAI POSTGRESQL
    if (isPostgreSQLConnected()) {
      try {
        const product = await getProductBySlug(slug);
        
        if (product) {
          console.log(`‚úÖ Produit trouv√© PostgreSQL: ${product.title}`);
          return res.json(product);
        }
        
      } catch (pgError) {
        console.error('‚ùå Erreur slug PostgreSQL:', pgError.message);
      }
    }
    
    // FALLBACK SLUG
    const product = fallbackProducts.find(p => p.slug === slug || p.id === slug);
    
    if (!product) {
      return res.status(404).json({ 
        error: 'Produit non trouv√©',
        slug: slug,
        source: 'fallback'
      });
    }
    
    console.log(`‚ö†Ô∏è Produit fallback: ${product.title}`);
    res.json(product);
    
  } catch (error) {
    console.error('‚ùå Erreur slug:', error);
    res.status(500).json({ 
      error: 'Erreur r√©cup√©ration produit',
      source: 'error'
    });
  }
});

// üìä ROUTE BARCODE - POSTGRESQL PRIORITAIRE
app.get('/api/products/barcode/:code', async (req, res) => {
  try {
    const { code } = req.params;
    const cleanBarcode = code.trim().replace(/[^\d]/g, '');
    
    if (cleanBarcode.length < 8) {
      return res.status(400).json({
        success: false,
        error: "Code-barres invalide",
        barcode: code,
        source: 'validation'
      });
    }
    
    console.log(`üîç Recherche barcode: ${cleanBarcode}`);
    
    // ESSAI POSTGRESQL EN PRIORIT√â
    if (isPostgreSQLConnected()) {
      try {
        const product = await getProductByBarcode(cleanBarcode);
        
        if (product) {
          console.log(`‚úÖ Produit trouv√© PostgreSQL: ${product.title}`);
          return res.json({
            success: true,
            product: product,
            barcode: cleanBarcode,
            search_method: 'postgresql_database',
            source: 'postgresql'
          });
        }
        
      } catch (pgError) {
        console.error('‚ùå Erreur barcode PostgreSQL:', pgError.message);
      }
    }
    
    // FALLBACK BARCODE
    const product = fallbackProducts.find(p => p.barcode === cleanBarcode);
    
    if (product) {
      console.log(`‚ö†Ô∏è Produit trouv√© fallback: ${product.title}`);
      return res.json({
        success: true,
        product: product,
        barcode: cleanBarcode,
        search_method: 'fallback_database',
        source: 'fallback'
      });
    }
    
    // PRODUIT NON TROUV√â
    console.log(`‚ùå Produit non trouv√©: ${cleanBarcode}`);
    res.status(404).json({
      success: false,
      error: "Produit non trouv√© dans notre base de donn√©es",
      barcode: cleanBarcode,
      suggestion_url: `/product-not-found?barcode=${cleanBarcode}`,
      message: "Aidez-nous √† enrichir notre base en photographiant ce produit",
      source: 'not_found'
    });
    
  } catch (error) {
    console.error('‚ùå Erreur barcode:', error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la recherche",
      message: error.message,
      source: 'error'
    });
  }
});

// üì∏ ROUTE ANALYSE PHOTOS
app.post('/api/products/analyze-photos', (req, res) => {
  const { barcode, photos } = req.body;

  if (!barcode || !photos) {
    return res.status(400).json({
      success: false,
      error: "Code-barres et photos requis"
    });
  }

  // TODO √âTAPE 3: Int√©grer vraie OCR
  res.json({
    success: true,
    message: "Produit analys√© et cr√©√© avec succ√®s",
    productName: "Produit √âco Analys√©",
    ecoScore: 75,
    redirect_url: `/product/produit-eco-${Date.now()}`,
    timestamp: new Date().toISOString(),
    source: 'postgresql_ready',
    note: '√âTAPE 3: OCR √† impl√©menter'
  });
});

// üè† ROOT ENDPOINT
app.get('/', async (req, res) => {
  try {
    let productCount = 0;
    let databaseStatus = 'Fallback uniquement';
    
    if (isPostgreSQLConnected()) {
      try {
        // Compter via pool PostgreSQL
        const { pool } = require('./db/pool');
        const client = await pool.connect();
        const result = await client.query('SELECT COUNT(*) as count FROM products');
        productCount = parseInt(result.rows[0].count);
        client.release();
        
        databaseStatus = 'PostgreSQL connect√©e ‚úÖ';
      } catch (error) {
        console.warn('‚ö†Ô∏è Erreur count PostgreSQL:', error.message);
        databaseStatus = 'PostgreSQL erreur, fallback actif';
        productCount = fallbackProducts.length;
      }
    } else {
      productCount = fallbackProducts.length;
      databaseStatus = 'PostgreSQL d√©connect√©e, fallback actif';
    }
    
    res.json({
      message: 'Ecolojia API - √âTAPE 1 R√âUSSIE',
      version: '1.1.0',
      status: 'operational',
      environment: process.env.NODE_ENV || 'production',
      timestamp: new Date().toISOString(),
      etape_status: '√âTAPE 1 TERMIN√âE - PostgreSQL activ√©',
      products_count: productCount,
      database: databaseStatus,
      postgresql_enabled: isPostgreSQLConnected(),
      prochaine_etape: '√âTAPE 2: Import OpenFoodFacts 200+ produits',
      endpoints: {
        products: [
          'GET /api/products ‚úÖ (PostgreSQL prioritaire)',
          'GET /api/products/search ‚úÖ (PostgreSQL prioritaire)', 
          'GET /api/products/:slug ‚úÖ (PostgreSQL prioritaire)',
          'GET /api/products/barcode/:code ‚úÖ (PostgreSQL prioritaire)',
          'POST /api/products/analyze-photos ‚úÖ (Pr√™t pour √âTAPE 3)'
        ],
        test: ['GET /api/test-barcode ‚úÖ'],
        health: ['GET /health ‚úÖ', 'GET /api/health ‚úÖ']
      }
    });
  } catch (error) {
    res.json({
      message: 'Ecolojia API - Erreur status',
      error: error.message,
      products_count: fallbackProducts.length,
      database: 'Fallback uniquement'
    });
  }
});

// üè• HEALTH CHECKS
app.get('/health', (req, res) => {
  const dbStatus = isPostgreSQLConnected() ? 'postgresql' : 'fallback';
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    database: dbStatus,
    etape: '√âTAPE 1 TERMIN√âE'
  });
});

app.get('/api/health', (req, res) => {
  const dbStatus = isPostgreSQLConnected() ? 'postgresql' : 'fallback';
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    database: dbStatus,
    etape: '√âTAPE 1 TERMIN√âE'
  });
});

// üîå INITIALISATION POSTGRESQL AU D√âMARRAGE
console.log('üîå Initialisation PostgreSQL...');
testConnection().then((success) => {
  if (success) {
    console.log('üéâ √âTAPE 1 R√âUSSIE - PostgreSQL activ√©');
    console.log('‚úÖ Base de donn√©es connect√©e');
    console.log('üöÄ Pr√™t pour √âTAPE 2: Import OpenFoodFacts');
  } else {
    console.log('‚ö†Ô∏è PostgreSQL indisponible - Mode fallback');
    console.log('üîß V√©rifiez DATABASE_URL et connexion r√©seau');
    console.log('üìã Fallback: 1 produit de maintenance disponible');
  }
}).catch((error) => {
  console.error('‚ùå Erreur initialisation PostgreSQL:', error);
  console.log('üîÑ Mode fallback par d√©faut');
});

// Nettoyage √† la fermeture
process.on('beforeExit', async () => {
  console.log('üîå Fermeture connexions...');
  const { pool } = require('./db/pool');
  if (pool) {
    await pool.end();
  }
});

module.exports = app;